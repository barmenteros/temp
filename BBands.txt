//@version=5
//2020 VERSION FINALE//
//Double band de bollinger stDev1 stDev2 et EMA 100 - EMA 200 - Hash Ribbon - Institutional bias et Pivot
//made by patoutheone - many indicators in one for free tradingview

//Ce script permet aux utilisateurs de tradingview gratuit d'avoir de multiples indicateurs en un.
//il se compose des doubles bandes de Bollinger avec 3 indicateurs (rouge vert bleu qui sont les EMA 20-40 et 60)
//Quand ces indicateurs sont dans l'ordre (de haut en bas) Rouge-Vert-Bleu c'est un signal haussier
//De plus j'ai rajouter l'EMA 100 en violet et l'EMA 200 en bleu foncé un peu plus épaisses.
//J'ai aussi rajouter par rapport a mon précédent script une partie de l'indicateur Hash Ribbon, juste les bulles sans les courbes pour une meilleur lisibilité.
//Vous avez aussi un indicateur d'entrée sur short ou long
//Ajout de l'indicateur Institutinal Bias en couleur Bleu clair et jaune.
//Tout les indicateurs sont identifiés de façon a ce que dans les options vous puissiez modifier ce que bon vous semble sans vous tromper.
//Vos commentaires sont les bienvenues

indicator(shorttitle=' BB-EMA-HR-8-34-BT-VF', title='Double Bollinger-Bands et EMA 8-34-50color-100-200 - hash Ribbon - bot Twin-version finale', overlay=true)

///////////////////////////Double BB et EMA////////////////////////////////////
length = input.int(20, title='Largeur de la BB', minval=1)  //Largeur de la BB, par defaut 20
src = input(close, title='Source BB')  //Source de la BB, par defaut close

// Inputs//
EMA_200 = input.int(200, minval=1)  //periode de la 4eme ema, par defaut 200
EMA_100 = input.int(100, minval=1)  //periode de la 5eme ema, par defaut 100
EMA_8 = input.int(8, minval=1)  //periode de la 6eme ema, par defaut 8 (roinono)
EMA_34 = input.int(34, minval=1)  //periode de la 7eme ema, par defaut 34(roinono)

// EMAs Values//
s4 = ta.ema(close, EMA_200)  //Source de l EMA, par defaut close
s5 = ta.ema(close, EMA_100)  //Source de l EMA, par defaut close
s6 = ta.ema(close, EMA_8)  //Source de l EMA, par defaut close
s7 = ta.ema(close, EMA_34)  //Source de l EMA, par defaut close

// EMA Plots et couleurs//
plot(s4, title='EMA 200', color=color.new(color.navy, 0), linewidth=4)
plot(s5, title='EMA 100', color=color.new(color.purple, 0), linewidth=4)
plot(s6, title='EMA 8', color=color.new(color.fuchsia, 0), linewidth=2)
plot(s7, title='EMA 34', color=color.new(color.orange, 0), linewidth=2)

//Bitcoin Investor Tool only ok in Daily
//len = input(730, minval=1, title="MA 730*5-Bitcoin Investor")
//src2 = input(close, title="Source")
//offset = input(title="Offset", type=input.integer, defval=0, minval=-500, maxval=500)
//out = sma(src2*5, len)
//plot(out, color=color.red, title="MA 730*5-Bitcoin Investor", offset=offset)

//len1 = input(730, minval=1, title="MA 730-Bitcoin Investor")
//src3 = input(close, title="Source")
//offset1 = input(title="Offset1", type=input.integer, defval=0, minval=-500, maxval=500)
//out1 = sma(src3, len1)
//plot(out1, color=color.green, title="MA 730-Bitcoin Investor", offset=offset1)

// EMA 50 colorisé pour Tendance
emaLength = input.int(50, minval=1, title='EMA Length')
emaSource = input(close, title='EMA Source')
// Get EMA and plot it
ema = ta.ema(emaSource, emaLength)
plot(ema, title='EMA de Tendance', color=close[1] > ema and close > ema ? color.green : color.red, linewidth=2, style=plot.style_circles)

//Doubles Bands de Bolingers//
//BB interieur//
stDev1 = input.float(1.0, minval=0.001, maxval=50)
basis = ta.sma(src, length)
dev = stDev1 * ta.stdev(src, length)
upper = basis + dev
lower = basis - dev

//colorisation BB interieur
p1 = plot(upper, title='BB Upper Interieur', color=color.new(color.green, 0))
p2 = plot(lower, title='BB Lower Interieur', color=color.new(color.red, 0))
fill(p1, p2, color=color.new(color.blue, 90), title='Couleur BG BB Upper-Lower Interieur')

//BB exterieur//
stDev2 = input.float(2.0, minval=0.001, maxval=50)
dev2 = stDev2 * ta.stdev(src, length)
upper2 = basis + dev2
lower2 = basis - dev2

//colorisation BB exterieur//
p3 = plot(upper2, title='BB Upper exterieur', color=color.new(color.green, 0), linewidth=3)
p4 = plot(lower2, title='BB Lower exterieur', color=color.new(color.red, 0), linewidth=3)
//p3 = plot(upper2, title="BB Upper exterieur", color=close[1] > ema and close > ema ? color.green : color.red, linewidth=3)
//p4 = plot(lower2, title="BB Lower exterieur", color=close[1] > ema and close > ema ? color.green : color.red, linewidth=3)
fill(p3, p4, color=color.new(color.blue, 90), title='Couleur BG BB Upper-Lower exterieur')


//////////////////////////////////////////// Hash Ribbons de capriole_charles ///////////////////////////////////////////////
// - Le premier cercle gris représente le début de "capitulation" (Le taux de hachage 1 mois passe sous le taux de hachage 2 mois)
// - le dernier cercle vert est la fin de la capitulation (Le taux de hachage 1 mois dépasse le taux de hachage 2 mois)
// - Le cercle le "plus vert" (jusqu'au bleu) représente la récupération du taux de hachage (il augmente)
// - Le cercle "bleu" est la marque d'un élan positif après la récupération du taux de hachage (1m HR> 2m HR). C'est historiquement un bon endroit pour acheter.

// INPUTS
type = input.string('Ribbons', options=['Ribbons', 'Oscillator'], title='Plot Type')
len_s = input(30, 'Hash Ribbons Short SMA (days).')
len_l = input(60, 'Hash Ribbons Long SMA (days).')
signals = input(true, 'Plot Hash Ribbons Signals')
plot_halvings = input(true, 'Plot Hash Ribbons Halvings')
//raw = input(false, "Plot Raw Hash Rate")

// HASH RATE MA
// HR on TV only has "yesterday's" value --> use "lookahead_on" when running live (on current bar), to pull forward yesterdays data
live_HR_raw = request.security('QUANDL:BCHAIN/HRATE', 'D', close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
live_HR_short = request.security('QUANDL:BCHAIN/HRATE', 'D', ta.sma(close, len_s), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
live_HR_long = request.security('QUANDL:BCHAIN/HRATE', 'D', ta.sma(close, len_l), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_on)
hist_HR_raw = request.security('QUANDL:BCHAIN/HRATE', 'D', close, gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
hist_HR_short = request.security('QUANDL:BCHAIN/HRATE', 'D', ta.sma(close, len_s), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
hist_HR_long = request.security('QUANDL:BCHAIN/HRATE', 'D', ta.sma(close, len_l), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
daily_s10 = request.security(syminfo.tickerid, 'D', ta.sma(close, 10), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)
daily_s20 = request.security(syminfo.tickerid, 'D', ta.sma(close, 20), gaps=barmerge.gaps_off, lookahead=barmerge.lookahead_off)

// DAILY TIMEFRAME MGMT
is_newbar(res) =>
    t = time(res)  // res calculated below \/
    ta.change(t) != 0 ? true : false

// Check how many bars are in our upper (otf) timeframe
since_new_bar = ta.barssince(is_newbar('D'))  //1-360 for minutes, D = Daily, W = Weekly, M = Monthly
D_total_bars = int(na)
D_total_bars := since_new_bar == 0 ? since_new_bar[1] : D_total_bars[1]  // calculates the total number of current time frame bars in the OTF 

// INDICATORS
HR_short = float(na)
HR_long = float(na)
HR_raw = float(na)
s10 = float(na)
s20 = float(na)
HR_short := barstate.isrealtime ? live_HR_short : hist_HR_short
HR_long := barstate.isrealtime ? live_HR_long : hist_HR_long
HR_raw := barstate.isrealtime ? live_HR_raw : hist_HR_raw
s10 := barstate.isrealtime ? since_new_bar == D_total_bars ? daily_s10 : s10[1] : daily_s10
s20 := barstate.isrealtime ? since_new_bar == D_total_bars ? daily_s20 : s20[1] : daily_s20
capitulation = ta.crossunder(HR_short, HR_long)
miner_capitulation = HR_short < HR_long
recovering = HR_short > HR_short[1] and HR_short > HR_short[2] and HR_short > HR_short[3] and miner_capitulation
recovered = ta.crossover(HR_short, HR_long)

// HASH BOTTOM + PA SIGNAL
buy = false
buy := s10 > s20 and (ta.barssince(recovered) < ta.barssince(ta.crossunder(s10, s20)) and ta.barssince(recovered) < ta.barssince(capitulation) or ta.crossover(HR_short, HR_long))

buy_plot = buy and buy[1] == false

// OSCILLATOR
delta = HR_short - HR_long
diff = delta / HR_short * 100

// PLOT - DEFAULT
//plot(raw ? HR_raw : na, color = color.green, linewidth = 1, style = plot.style_line, title='HR Raw') 
//p1=plot(type=='Ribbons'? HR_long : na, color = color.gray, linewidth = 2, style = plot.style_line,title='HR SMA Long') 
//p2=plot(type=='Ribbons'? HR_short : na, color = (HR_short<HR_long? color.red : color.lime), linewidth = 2, style = plot.style_line,title = 'HR SMA Short')
//fill(p1,p2,color=(HR_short<HR_long?color.red:na),transp=30)

// PLOT - OSCILLATOR
//plot(type=='Oscillator' ? diff : na,style=plot.style_columns,color=(diff<0?color.red:color.blue),title='Oscillator')

// PLOT - SIGNALS
plotshape(signals ? capitulation : na, style=shape.circle, location=location.top, color=color.new(color.gray, 50), size=size.normal, text='Capitulation', textcolor=color.new(color.black, 50), title='Capitulation')
plotshape(signals ? miner_capitulation : na, style=shape.circle, location=location.top, color=color.new(color.green, 90), size=size.normal, title='Miner Capitulation')
plotshape(signals ? recovering : na, style=shape.circle, location=location.top, color=color.new(color.green, 50), size=size.normal, title='Recovering')
plotshape(signals ? recovered : na, style=shape.circle, location=location.top, color=color.new(color.lime, 0), size=size.normal, textcolor=color.new(color.white, 0), title='Recovered')
plotshape(signals ? buy_plot : na, style=shape.circle, location=location.top, color=color.new(color.blue, 0), size=size.normal, text='Buy', textcolor=color.new(color.blue, 0), title='Buy')

//ALERTS
alertcondition(capitulation, title='Alert - Capitulation')
alertcondition(recovered, title='Alert - Recovered')
alertcondition(buy and not buy[1], title='Alert - Buy')

//////////////////////////////////HALVINGS///////////////////////////////////////////////////////
halving_3 = timestamp(2020, 5, 11, 0, 0)  // projected! https://www.bitcoinclock.com/
h3_range = time >= halving_3 - 1 * 24 * 60 * 60 * 1000 and time <= halving_3 + 1 * 24 * 60 * 60 * 1000  //adds 1 day either side for chart visibility
bgcolor(h3_range and plot_halvings ? color.red : na, title='Bg Hash Ribbon Halving 2020', transp=70)


//////////////////////////////////////////////////////////////////////////////////////////////////////////////    
///////////////////////////////////////////////partie Bot/////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////


//////////////////////////////////Twin range filter///////////////////////////////////////////////////////
source = input(defval=close, title='Source')

// Smooth Average Range

per1 = input.int(defval=27, minval=1, title='Fast period')
mult1 = input.float(defval=1.6, minval=0.1, title='Fast range')

per2 = input.int(defval=55, minval=1, title='Slow period')
mult2 = input.float(defval=2, minval=0.1, title='Slow range')

smoothrng(x, t, m) =>
    wper = t * 2 - 1
    avrng = ta.ema(math.abs(x - x[1]), t)
    smoothrng = ta.ema(avrng, wper) * m
    smoothrng
smrng1 = smoothrng(source, per1, mult1)
smrng2 = smoothrng(source, per2, mult2)
smrng = (smrng1 + smrng2) / 2

// Range Filter

rngfilt(x, r) =>
    rngfilt = x
    rngfilt := x > nz(rngfilt[1]) ? x - r < nz(rngfilt[1]) ? nz(rngfilt[1]) : x - r : x + r > nz(rngfilt[1]) ? nz(rngfilt[1]) : x + r
    rngfilt
filt = rngfilt(source, smrng)

upward = 0.0
upward := filt > filt[1] ? nz(upward[1]) + 1 : filt < filt[1] ? 0 : nz(upward[1])
downward = 0.0
downward := filt < filt[1] ? nz(downward[1]) + 1 : filt > filt[1] ? 0 : nz(downward[1])

hband = filt + smrng
lband = filt - smrng

longCond = bool(na)
shortCond = bool(na)
longCond := source > filt and source > source[1] and upward > 0 or source > filt and source < source[1] and upward > 0
shortCond := source < filt and source < source[1] and downward > 0 or source < filt and source > source[1] and downward > 0

CondIni = 0
CondIni := longCond ? 1 : shortCond ? -1 : CondIni[1]

long = longCond and CondIni[1] == -1
short = shortCond and CondIni[1] == 1

// Plotting

plotshape(long, title='Long', text='Long', style=shape.labelup, textcolor=color.new(color.black, 0), size=size.tiny, location=location.belowbar, color=color.new(color.lime, 0))
plotshape(short, title='Short', text='Short', style=shape.labeldown, textcolor=color.new(color.white, 0), size=size.tiny, location=location.abovebar, color=color.new(color.red, 0))

// Alerts

alertcondition(long, title='Long', message='Long')
alertcondition(short, title='Short', message='Short')

//////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////Pi Cycle indicateur de sommet////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////

len_ma_long = input.int(350, minval=1, title='Long Moving Average')
len_ma_short = input.int(111, minval=1, title='Short Moving Average')
resolution = input('D', title='Time interval')
is_show_ma = input(false, title='Show Moving Averages ?')
is_alert = input(true, title='Send an alert on Pi Cycle Top?')

ma_long = request.security(syminfo.tickerid, resolution, ta.sma(close, len_ma_long) * 2)
ma_short = request.security(syminfo.tickerid, resolution, ta.sma(close, len_ma_short))
src1 = request.security(syminfo.tickerid, resolution, close)

plot(is_show_ma ? ma_long : na, color=color.new(color.green, 0))
plot(is_show_ma ? ma_short : na, color=color.new(color.red, 0))

PiCycleTop = ta.crossunder(ma_long, ma_short) ? src + src / 100 * 10 : na

plotshape(PiCycleTop, style=shape.labeldown, size=size.normal, text='Attention top', color=color.new(color.red, 0), textcolor=color.new(color.white, 0), location=location.absolute)
alertcondition(condition=PiCycleTop, title='Pi Cycle', message='Sommet atteind, gaffe a la chute')